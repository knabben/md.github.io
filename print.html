<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>the ancient grimoire</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="winapi/init.html">Windows API</a></li><li class="chapter-item expanded "><a href="winapi/1.html"><strong aria-hidden="true">1.</strong> Chapter 1</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="rust/init.html"><strong aria-hidden="true">2.</strong> ðŸ¦€ Rust</a></li><li class="chapter-item expanded "><a href="rust/day_1.html"><strong aria-hidden="true">3.</strong> Day 1</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust/day1/1.html"><strong aria-hidden="true">3.1.</strong> Beginning it</a></li><li class="chapter-item expanded "><a href="rust/day1/2.html"><strong aria-hidden="true">3.2.</strong> Variables lifecycle</a></li></ol></li><li class="chapter-item expanded "><a href="rust/day_2.html"><strong aria-hidden="true">4.</strong> Day 2</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust/day2/exercises1.html"><strong aria-hidden="true">4.1.</strong> Exercises part I</a></li><li class="chapter-item expanded "><a href="rust/day2/exercises2.html"><strong aria-hidden="true">4.2.</strong> Exercises part II</a></li></ol></li><li class="chapter-item expanded "><a href="rust/day_3.html"><strong aria-hidden="true">5.</strong> Day 3</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust/day3/exercises1.html"><strong aria-hidden="true">5.1.</strong> Exercises part I</a></li><li class="chapter-item expanded "><a href="rust/day3/exercises2.html"><strong aria-hidden="true">5.2.</strong> Exercises part II</a></li></ol></li><li class="chapter-item expanded "><a href="rust/day_4.html"><strong aria-hidden="true">6.</strong> Day 4</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="aws/network/init.html">AWS</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">the ancient grimoire</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="windows-notebook"><a class="header" href="#windows-notebook">Windows notebook</a></h1>
<p>Notes from Windows Internal 7th Edition and general debugging rules</p>
<p><a href="winapi/./1.html">Chapter 1</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="windows-introduction"><a class="header" href="#windows-introduction">Windows Introduction</a></h1>
<p>Introductory chapter about MS Windows OS concepts and terms used in the book. Intro of the Windows 
<a href="http://www.microsoft.com/technet/sysinternals">sysinternals</a>. Summary of Windows Driver Kit (WDK),
Windows Software Development Kit (SDK).</p>
<h2 id="versions"><a class="header" href="#versions">Versions</a></h2>
<p>Accordingly the <a href="https://learn.microsoft.com/en-us/windows-server/get-started/windows-server-release-info">MS site</a> 
the following versions are available as server Windows options.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: right">Windows Server Release</th><th style="text-align: right">Servicing options</th><th style="text-align: right">Availability</th></tr></thead><tbody>
<tr><td style="text-align: right">Windows Server 2022</td><td style="text-align: right">LTSC</td><td style="text-align: right">2021-08-18</td></tr>
<tr><td style="text-align: right">Windows Server 2019</td><td style="text-align: right">LTSC</td><td style="text-align: right">2018-11-13</td></tr>
<tr><td style="text-align: right">Windows Server 2016</td><td style="text-align: right">LTSC</td><td style="text-align: right">2016-10-15</td></tr>
</tbody></table>
</div>
<h2 id="windows-api"><a class="header" href="#windows-api">Windows API</a></h2>
<p>Ms core set of application programming interfaces available in MS OSs. 
Several implementations that are often referred to by their own names (win32 api)
Almost all Windows programs interact with the Windows API. Developer support
is implemented in a form a software development kit, or MS SDK. WinAPI mostly
focus on C. kernel32.dll is a core DLL exposing to applications most of the Win32 base API, such as memory mngmt,
input/output, process and thread creation, (linux equivalent = libc).</p>
<p>winRT or Windows Runtime is built on top of COM, adding various extensions to the base infrastructure
.NET fw is part of Windows, uses the CLR (common lang runtime) and FCL for user development support.
A few contexts for libraries and services:</p>
<ul>
<li>Windows API functions</li>
<li>Native System Services (system calls)</li>
<li>Kernel support functions (or routines)</li>
<li>Windows Services</li>
<li>Dynamic Link Libraries</li>
</ul>
<h2 id="processes"><a class="header" href="#processes">Processes</a></h2>
<p>Program vs. Process with the following differences: Process has a private vritual adress space, 
an executable program, a list of open handlers, a security context, a processs ID and at least
one thread.</p>
<p><img src="winapi/./images/proc.png" alt="screenshot of process" /></p>
<p>Jobs- Windows provides an extension of the process model called jobs, a job object main functions is to
allow the management and manipulations of a group of processes as a unit.</p>
<h2 id="virtual-memory"><a class="header" href="#virtual-memory">Virtual Memory</a></h2>
<p>Implements a virtual mem system based on flat address space, provides each process with illusion of having its
large address space. Translates and maps the virtual address into physical addr where the data is actually stored.
paging data to disk frees physical memory so that it can be used for other processes or for the OS itself.
When a thread accesses a vritual address that has been paged to disk, VMem manager loads the info back into memory from disk.</p>
<p>Address Windowing Extensions (AWE) allows 32-bit apps allocate up to 64Gb of physical memory.
64-bit windows provides 128 TB.</p>
<h2 id="kernel-mode-vs-user-mode"><a class="header" href="#kernel-mode-vs-user-mode">Kernel mode vs. user mode</a></h2>
<p>running processes in different modes (ring levels), providing the Os kernel with higher privileges level
than user model apps have, the processor provides a necessary foundation for OS designers to ensure 
misbehaving apps don't disrupt the system. User apps switch from user to kernel mode when they make a system
service call.</p>
<p><img src="winapi/./images/netproc.png" alt="screenshot of process" /></p>
<p>Windows provides DAC, Privileged access control and mandatory integrity control </p>
<h2 id="kernel-debugging"><a class="header" href="#kernel-debugging">Kernel debugging</a></h2>
<p>Examining internal kernel data structures and steping through functions in the kernel
Useful way to investigate Windows int. Debugging tools:</p>
<ol>
<li>cdb</li>
<li>kd</li>
<li>WinDBc</li>
<li>User-mode debuggers</li>
<li>Kernel-mode debuggers</li>
</ol>
<p>Install the SDK with the following command</p>
<pre><code>Invoke-WebRequest -URI &quot;https://go.microsoft.com/fwlink/p/?linkid=2196241&quot; -Out sdk.exe
sdk.exe
</code></pre>
<p>To force a crash you can run <code>notMyfault.exe /crash</code></p>
<p>If KD or WinDbg is performing kernel-mode debugging, it can force a system crash to occur. This is done by entering the .crash (Force System Crash) command at the command prompt. (If the target computer does not crash immediately, follow this with the g (Go) command.)</p>
<p><img src="winapi/./images/kernel.png" alt="screenshot of mem" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-rust-annotations"><a class="header" href="#-rust-annotations">ðŸ¦€ Rust annotations</a></h1>
<p>This document is following the days and research mainly from the <a href="https://google.github.io/comprehensive-rust/">Comprehensive Rust</a> book.
The tutorial consist of 4 days passing in different topics of the language</p>
<h3 id="support-related-material"><a class="header" href="#support-related-material">Support related material</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/book/">OS Rust book</a></li>
<li><a href="http://shop.oreilly.com/product/0636920040385.do">Programming Rust v2</a></li>
<li><a href="https://doc.rust-lang.org/stable/rust-by-example/">Rust by Example</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="day-1---122023"><a class="header" href="#day-1---122023">Day 1 - 1/2/2023</a></h3>
<p>Modern systems programming language focusing on <em>safety</em>, <em>speed</em> and <em>concurrency</em>.
Accomplishes these goals by being memory safe without using garbage collection.</p>
<h3 id="rust-editions"><a class="header" href="#rust-editions"><a href="https://doc.rust-lang.org/edition-guide/editions/index.html">Rust editions</a></a></h3>
<p>Backport using cargo <code>--edition</code>, <code>cargo fix</code> can help  on code base migration</p>
<ul>
<li>Rust 2015 (May) - stability without stagnation
<ul>
<li>Do not have async or await keywords</li>
</ul>
</li>
<li>Rust 2018</li>
<li>Rust 2021 (latest) - 1.56.0 - RFC #3085</li>
</ul>
<p>Current version used:</p>
<pre><code>$ cargo version
cargo 1.66.0 (d65d197ad 2022-11-15)
</code></pre>
<h2 id="tools-and-binaries"><a class="header" href="#tools-and-binaries">Tools and binaries</a></h2>
<p>Install Rust on ~/.cargo with the following command</p>
<pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<p>Shell configuration is already made, toolchain management is made via <code>rustup</code> (i.e. gimme or pyenv)</p>
<p><code>cargo</code> (pkg manager) is the tool responsible to manage projects, install dependencies, run tests, etc.</p>
<pre><code class="language-shell">cargo --help
Some common cargo commands are (see all commands with --list):
    build, b    Compile the current package
    check, c    Analyze the current package and report errors, but don't build object files
    clean       Remove the target directory
    doc, d      Build this package's and its dependencies' documentation
    new         Create a new cargo package
    init        Create a new cargo package in an existing directory
    add         Add dependencies to a manifest file
    remove      Remove dependencies from a manifest file
    run, r      Run a binary or example of the local package
    test, t     Run the tests
    bench       Run the benchmarks
    update      Update dependencies listed in Cargo.lock
    search      Search registry for crates
    publish     Package and upload this package to the registry
    install     Install a Rust binary. Default location is $HOME/.cargo/bin
    uninstall   Uninstall a Rust binary
</code></pre>
<p>Other binaries includes:</p>
<ul>
<li>rustc - rust compiler</li>
<li>mdbook - create markdown books like this one</li>
<li>rustfmt - linter and formatter</li>
<li>rustup - toolchain installer</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="day-1-basic-rust-ownership-and-the-borrow-checker"><a class="header" href="#day-1-basic-rust-ownership-and-the-borrow-checker">Day 1: Basic Rust, ownership and the borrow checker.</a></h2>
<h3 id="basic-rust"><a class="header" href="#basic-rust">Basic Rust</a></h3>
<ul>
<li>
<p>rustc uses LLVM </p>
</li>
<li>
<p>Multiple architectures (WASM included)</p>
<ul>
<li><code>cargo build --target wasm32-unknown-unknown</code></li>
</ul>
</li>
<li>
<p>Basic rust syntax: </p>
<ul>
<li>Variables, </li>
<li>Scalar and compound types,</li>
<li>Enums, </li>
<li>Structs References, </li>
<li>Functions and Methods</li>
</ul>
</li>
<li>
<p>Memory management: </p>
<ul>
<li>stack vs heap, </li>
<li>manual memory management, </li>
<li>scope based memory management and gc</li>
</ul>
</li>
<li>
<p>Ownership: </p>
<ul>
<li>move semantics, </li>
<li>copying and cloning, </li>
<li>borrowing and lifetimes</li>
</ul>
</li>
</ul>
<h3 id="syntax-sugar"><a class="header" href="#syntax-sugar">Syntax sugar</a></h3>
<ul>
<li>Blocks are delimited by curly braces</li>
<li><code>main</code> is the entry point</li>
<li>Provides hygienic macros and utf-8 encoded and contain unicode</li>
</ul>
<h3 id="types"><a class="header" href="#types">Types</a></h3>
<h4 id="scalar-types"><a class="header" href="#scalar-types">Scalar types</a></h4>
<div class="table-wrapper"><table><thead><tr><th></th><th>Types</th><th>Literals</th></tr></thead><tbody>
<tr><td>Signed integers</td><td><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, <code>isize</code></td><td><code>-10</code>, <code>0</code>, <code>1_000</code>, <code>123i64</code></td></tr>
<tr><td>Unsigned integers</td><td><code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, <code>usize</code></td><td><code>0</code>, <code>123</code>, <code>10u16</code></td></tr>
<tr><td>Floating point numbers</td><td><code>f32</code>, <code>f64</code></td><td><code>3.14</code>, <code>-10.0e20</code>, <code>2f32</code></td></tr>
<tr><td>Strings</td><td><code>&amp;str</code></td><td><code>&quot;foo&quot;</code>, <code>r#&quot;\\&quot;#</code></td></tr>
<tr><td>Unicode scalar values</td><td><code>char</code></td><td><code>'a'</code>, <code>'Î±'</code>, <code>'âˆž'</code></td></tr>
<tr><td>Byte strings</td><td><code>&amp;[u8]</code></td><td><code>b&quot;abc&quot;</code>, <code>br#&quot; &quot; &quot;#</code></td></tr>
<tr><td>Booleans</td><td><code>bool</code></td><td><code>true</code>, <code>false</code></td></tr>
</tbody></table>
</div>
<h4 id="compound-types"><a class="header" href="#compound-types">Compound Types</a></h4>
<div class="table-wrapper"><table><thead><tr><th></th><th>Types</th><th>Literals</th></tr></thead><tbody>
<tr><td>Arrays</td><td><code>[T; N]</code></td><td><code>[20, 30, 40]</code>, <code>[0; 3]</code></td></tr>
<tr><td>Tuples</td><td><code>(T1, T2, T3, ...)</code></td><td><code>('x', 1.2, 0)</code></td></tr>
</tbody></table>
</div>
<p>Other data structures exists:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/collections/index.html#">Official collections</a></li>
<li><a href="https://github.com/TheAlgorithms/Rust">Thirdy part Algo implementation</a></li>
</ul>
<h3 id="variables"><a class="header" href="#variables">Variables</a></h3>
<p><code>mut</code> is used when a variable is initialized and needs to be changed later.
<code>!</code> marks this as a macro invocation, not a function call.
<code>let</code> statements declare local variables </p>
<pre><pre class="playground"><code class="language-rust editable">fn function1() -&gt; i32 {
    let _logical: bool = true;
    let _a_float: f64 = 1.0;
    let _an_integer = 5i32;

    let _default_int = 2; // i32

    let mut mutablevar = 12;
    mutablevar = 35;

    return mutablevar;
}

fn main() {
    let out = function1();
    println!(&quot;{}&quot;, out);
}</code></pre></pre>
<h3 id="pointers"><a class="header" href="#pointers">Pointers</a></h3>
<p>Similar to golang and pointers are treated with references and <code>&amp;</code></p>
<pre><pre class="playground"><code class="language-rust editable">use rand::Rng;
use std::cmp::Ordering;

fn main() {
    let guess :i32 = 10;
    let secret_number :&amp;i32 = &amp;rand::thread_rng().gen_range(1..=10);

    match guess.cmp(secret_number) {
        Ordering::Less =&gt; println!(&quot;Too small!&quot;),
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
        Ordering::Equal =&gt; println!(&quot;You win!&quot;),
    }
    
    println!(&quot;{}&quot;, *secret_number)
}</code></pre></pre>
<p>The main aim of lifetimes is to prevent <em>dangling references</em>, 
which cause a program to reference data other than the data itâ€™s intended to reference.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let ref_x: &amp;i32;
    {
        let x: i32 = 10;
        ref_x = &amp;x;
    }
    println!(&quot;ref_x: {ref_x}&quot;);
}</code></pre></pre>
<p>Won't compile because the value <code>ref_x</code> is referring to has gone out of scope before we try to use it.</p>
<h3 id="slices"><a class="header" href="#slices">Slices</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
  let s = String::from(&quot;hello world&quot;);

  let hello = &amp;s[0..5];
  let world = &amp;s[6..s.len()];
  
  println!(&quot;slices: {}, {}&quot;, hello, world)
}</code></pre></pre>
<h3 id="functions-and-methods"><a class="header" href="#functions-and-methods">Functions and methods</a></h3>
<ul>
<li>Functions are introduced with <code>fn</code> (pronounced &quot;fun&quot;)</li>
<li>Methods comes from <code>structs</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">struct Square {
    width: i32
}

impl Square {
    fn area(&amp;self) -&gt; i32 {
        return i32::pow(self.width, 2)
    }
}

fn main() {
    let sq :Square = Square{width: 10};
    let area :i32 = sq.area();
    println!(&quot;{area}&quot;);
}</code></pre></pre>
<h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<p>A few implicit conversions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;{x} * {y} = {} -- {} {}&quot;, multiply(i16::from(x), y), y.to_string(), f64::from(y));
<span class="boring">}</span></code></pre></pre>
<p>Array loops, matrices transposition.</p>
<pre><pre class="playground"><code class="language-rust">fn transpose(mut matrix: [[i32; 3]; 3]) -&gt; [[i32; 3]; 3] {
    // returning cloned transpose for now. requires research on borrowing concept.
    let mut new_matrix:[[i32; 3]; 3] = matrix.clone();
    for (i, r) in matrix.iter().enumerate() {
        for (j, _c) in r.iter().enumerate() {
            new_matrix[i][j] = matrix[j][i];
        }
    }
    return new_matrix
}

fn pretty_print(matrix: &amp;[[i32; 3]; 3]) {
    println!(&quot;{:?}&quot;, matrix);
}

fn main() {
    let matrix = [
        [101, 102, 103], // &lt;-- the comment makes rustfmt add a newline
        [201, 202, 203],
        [301, 302, 303],
    ];

    println!(&quot;matrix:&quot;);
    pretty_print(&amp;matrix);

    let transposed = transpose(matrix);
    println!(&quot;transposed:&quot;);
    pretty_print(&amp;transposed);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="variables-1"><a class="header" href="#variables-1">Variables</a></h3>
<p>By default, variables are immutable, need to use <code>mut</code>. Static typing 
allow type inference, do not pass the type <code>:&lt;type&gt;</code>, and let rust infer it.</p>
<p><code>const</code> use the compile-time constants.</p>
<h4 id="shadowing"><a class="header" href="#shadowing">Shadowing</a></h4>
<p>Declare a variable with the same name as a previous variable.
The first variable is shadowed by the second on this case.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let x = x + 1;

    {
        let x = 100;
        println!(&quot;inner scope: {x}&quot;);
        let x = true;
        println!(&quot;shadowed in inner scope: {x}&quot;);
    }
    
    println!(&quot;outer scope {x}&quot;);
}</code></pre></pre>
<h3 id="memory-management"><a class="header" href="#memory-management">Memory management</a></h3>
<p>Rust offers full control AND safety via compile time enforcement of correct memory management.
Explicit Ownership concept.</p>
<p><em>Refer to mem management section from the tutorial.</em></p>
<h2 id="ownership"><a class="header" href="#ownership">Ownership</a></h2>
<p>Binding have a scope where they are valid.
A set of rules that govern how a Rust program manages memory.
All programs have to manage the way they use memory while running.
Memory is managed through a system of ownership with a set of rules that the compiler checks.</p>
<ul>
<li>Each value has an <em>owner</em></li>
<li>There can only be one owner at a time.</li>
<li>When the owner goes out of scope, the value is dropped.</li>
</ul>
<h3 id="move"><a class="header" href="#move">Move</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);
    let s2: String = s1;
}</code></pre></pre>
<p>Data is moved from one s1 and s1 is not accessible anymore - 
This is a problem: when s2 and s1 go out of scope, they will both try to free the same memory. This is known as a double free error and is one of the memory safety bugs we mentioned previously. Freeing memory twice can lead to memory corruption, which can potentially lead to security vulnerabilities.
Rust doesnâ€™t need to free anything when s1 goes out of scope. when accessing it raises an error:</p>
<p><code>value is borrowed here after move.</code></p>
<p>Transfer ownership happens on function parameters as well.
Another way to interect is via <code>s1.close()</code>.</p>
<p>Struct must use <code>#[derive(Copy, Clone, Debug)]</code> annotation.</p>
<p>For functions is not allowed to use s after the function ownership taken</p>
<pre><pre class="playground"><code class="language-rust">fn takes_ownership(s :String) {
    println!(&quot;on function: {}&quot;, s)
}

fn main() {
    let s = String::from(&quot;hello&quot;);  // s comes into scope

    takes_ownership(s);             // s's value moves into the function...
    println!(&quot;outside function: {}&quot;, s)
}</code></pre></pre>
<h3 id="borrowing-and-lifetimes"><a class="header" href="#borrowing-and-lifetimes">Borrowing and lifetimes</a></h3>
<p>Passing references (<code>&amp;</code>) makes the data still being owner by some other variable.
<code>function(&amp;s1)</code>, allows to refer the value of s1 but do not own it. 
The caller retains ownership of the inputs.</p>
<pre><pre class="playground"><code class="language-rust">
fn main() {
    let p1 = String::from(&quot;hello&quot;);
    let f1;
    
    {
        let p2 :String = String::from(&quot;hello 2&quot;);
        f1 = function(&amp;p1.as_str(), &amp;p2.as_str());
    }
    
    println!(&quot;{f1} {p1}&quot;);
}

// returns with p2 lifetime if p2 has 'a.
// forcing the lifetime for the p1 variable allows the
// return.
fn function&lt;'a&gt;(p1 :&amp;'a str, p2 :&amp;str) -&gt; &amp;'a str{ ;; 
    println!(&quot;function {p1} {p2}&quot;);
    return p1
}</code></pre></pre>
<p>These borrowed values has a <code>lifetime</code> -  ensure that references are valid as long as we need them to be.
<code>&amp;'a String</code> means â€œa borrowed String which is valid for at least the lifetime a`</p>
<p>Reference:</p>
<p>https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html?highlight=lifetime#lifetime-elision</p>
<h3 id="exercises-1"><a class="header" href="#exercises-1">Exercises</a></h3>
<ul>
<li>Designing a library</li>
</ul>
<pre><pre class="playground"><code class="language-rust">impl Library {
    fn new(books :Vec&lt;Book&gt;) -&gt; Library {
        Library{ books }
    }

    fn len(&amp;self) -&gt; usize {
        self.books.len()
    }

    fn is_empty(&amp;self) -&gt; bool {
        self.books.is_empty()
    }

    fn add_book(&amp;mut self, book: Book) {
        self.books.push(book)
    }

    fn print_books(&amp;self) {
        for b in self.books.iter() {
            println!(&quot;{}&quot;, b)
        }
    }

    fn oldest_book(&amp;mut self) -&gt; Option&lt;&amp;Book&gt; {
        self.books.sort_by(|a, b| a.year.cmp(&amp;b.year));
        self.books.first()
    }
}

fn main() {
    // This shows the desired behavior. Uncomment the code below and
    // implement the missing methods. You will need to update the
    // method signatures, including the &quot;self&quot; parameter!
    let books :Vec&lt;Book&gt; = vec!();
    let mut library = Library::new(books);

    println!(&quot;Our library is empty: {}&quot;, library.is_empty());

    library.add_book(Book::new(&quot;Lord of the Rings&quot;, 1954));
    library.add_book(Book::new(&quot;Alice's Adventures in Wonderland&quot;, 1865));

    library.print_books();

    match library.oldest_book() {
        Some(book) =&gt; println!(&quot;My oldest book is {book}&quot;),
        None =&gt; println!(&quot;My library is empty!&quot;),
    }

   println!(&quot;Our library has {} books&quot;, library.len());
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="day-2---132023"><a class="header" href="#day-2---132023">Day 2 - 1/3/2023</a></h3>
<p>Structs are cool, methods can access the struct pointer
Possible to use a tuple struct - normally used for single field wrappers</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum TShirt {
    L,
    M,
    P,
}

struct Newtons(f64);

struct Member {
    name :String,
    force :Newtons,
    tshirt :TShirt,
}

impl Member {
    fn set_force(&amp;mut self, force :Newtons) {
       self.force = force 
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Usage of method receivers:</p>
<ul>
<li>&amp;self : borrows the object from the caller using a shared and immutable reference.</li>
<li>&amp;mut self: borrows the object from the caller using a unique and mutable reference.</li>
<li>self: takes ownership of the object and moves it away from the caller.</li>
<li>none: status method on the struct.</li>
</ul>
<p>after taking ownership with self, the variable is moved and cannot be borrowed back.</p>
<h3 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern matching</a></h3>
<p>This is an important feature of switch case that can be extended to more complex pattterns
latter, </p>
<pre><pre class="playground"><code class="language-rust">enum Result {
    Ok(i32),
    Error(String),
}

fn main() {
    let has_result = Result::Error(&quot;msg&quot;.to_string());
    match has_result {
        Result::Ok(n) =&gt; println!(&quot;received {n}&quot;),
        _ =&gt; println!(&quot;default&quot;),
    }
}</code></pre></pre>
<p>Deconstructuring enums/struct and Arrays - </p>
<pre><pre class="playground"><code class="language-rust editable">enum Temperature {
    Celsius(i32),
}

struct SomeStruct {
    a: u32,
    b: u32,
}

fn main() {
   let ss = SomeStruct{a: 2000, b: 0 };
    match ss {
        SomeStruct { a: 1, b } =&gt; println!(&quot; a = {b} &quot;),
        SomeStruct { .. } =&gt; println!(&quot; default a &quot;),
    }

    // match guards
    let temp = Temperature::Celsius(36);
    match temp {
        Temperature::Celsius(t) if t &gt; 40 =&gt; println!(&quot;Is high {t}&quot;),
        Temperature::Celsius(t) =&gt; println!(&quot;Is high {t}&quot;),
    }
}</code></pre></pre>
<h3 id="control-flows"><a class="header" href="#control-flows">Control flows</a></h3>
<p>The old boring if, if let, while, while let, for, loop (endless), match, breaks 
and continue. Blocks are allowed with <code>{}</code> and keep the scope.</p>
<h3 id="standard-library"><a class="header" href="#standard-library">Standard library</a></h3>
<p>the standard library has a set of common types that are important</p>
<ul>
<li>Option and Result: used for optional values and error handling.</li>
<li>Box: an owned pointer for heap-allocated data.</li>
<li>Rc: a shared reference-counted pointer for heap-allocated data.</li>
</ul>
<p>Use Rc when need to refer to the same data from multiple places.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s = [false, true, false, true, false, true];
    let value =  s.binary_search_by(|p| p.cmp(&amp;false));

    assert_eq!(value, Ok(0));

    let five = Box::new(100);
    println!(&quot;{}&quot;, *five);

    let a = Rc::new(1);
    let b = a.clone();

    println!(&quot;a: {a}&quot;);
    println!(&quot;b: {b}&quot;);
}</code></pre></pre>
<h2 id="modules"><a class="header" href="#modules">Modules</a></h2>
<p>Starts with <code>mod</code>, <code>pub fn</code> allows public access.
Access with <code>&lt;mod&gt;::function</code>. Folders have a <code>mod.rs</code> to declare the module.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="exercises-day-2---part-i"><a class="header" href="#exercises-day-2---part-i">Exercises day 2 - Part I</a></h2>
<ul>
<li>Simple struct which tracks health statistics.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">struct User {
    name: String,
    age: u32,
    weight: f32,
}

impl User {
    pub fn new(name: String, age: u32, weight: f32) -&gt; Self {
        return User{name, age, weight}
    }

    pub fn name(&amp;self) -&gt; &amp;str {
        &amp;self.name
    }

    pub fn age(&amp;self) -&gt; u32 {
        self.age
    }

    pub fn weight(&amp;self) -&gt; f32 {
        self.weight
    }

    pub fn set_age(&amp;mut self, new_age: u32) {
        self.age = new_age
    }

    pub fn set_weight(&amp;mut self, new_weight: f32) {
        self.weight = new_weight
    }
}

fn main() {
    let bob = User::new(String::from(&quot;Bob&quot;), 32, 155.2);
    println!(&quot;I'm {} and my age is {}&quot;, bob.name(), bob.age());
}

#[test]
fn test_weight() {
    let bob = User::new(String::from(&quot;Bob&quot;), 32, 155.2);
    assert_eq!(bob.weight(), 155.2);
}

#[test]
fn test_set_age() {
    let mut bob = User::new(String::from(&quot;Bob&quot;), 33, 155.2);
    assert_eq!(bob.age(), 32);
    bob.set_age(33);
    assert_eq!(bob.age(), 33);
}</code></pre></pre>
<ul>
<li>Multiple structs and enums for a drawing library.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::Add;

#[derive(Debug, Copy, Clone, PartialEq)]
pub struct Point {
    x :i32,
    y :i32,
}

impl Add for Point {
    type Output = Self;

    fn add(self, other: Self) -&gt; Self {
        Self {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

impl Point {
    fn new(x :i32, y :i32) -&gt; Point {
        Point{x, y}
    }
    fn magnitude(&amp;self) -&gt; f64 {
        f64::sqrt( (i32::pow(self.x, 2) + i32::pow(self.y, 2)).into())
    }

    fn dist(&amp;self, p1 :Point) -&gt; f64{
        f64::sqrt( (i32::pow(p1.x - self.x, 2) + i32::pow(p1.y - self.y, 2)).into())
    }
}

pub struct Polygon {
    points :Vec&lt;Point&gt;
}

impl Polygon {
    fn new() -&gt; Polygon {
        Polygon{ points: vec![]}
    }

    fn add_point(&amp;mut self, p :Point) {
        self.points.push(p)
    }
    fn left_most_point(&amp;self) -&gt; Option&lt;&amp;Point&gt; {
       self.points.first()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn round_two_digits(x: f64) -&gt; f64 {
        (x * 100.0).round() / 100.0
    }

    #[test]
    fn test_point_magnitude() {
        let p1 = Point::new(12, 13);
        assert_eq!(round_two_digits(p1.magnitude()), 17.69);
    }

    #[test]
    fn test_point_dist() {
        let p1 = Point::new(10, 10);
        let p2 = Point::new(14, 13);
        assert_eq!(round_two_digits(p1.dist(p2)), 5.00);
    }

    #[test]
    fn test_point_add() {
        let p1 = Point::new(16, 16);
        let p2 = p1 + Point::new(-4, 3);
        assert_eq!(p2, Point::new(12, 19));
    }

    #[test]
    fn test_polygon_left_most_point() {
        let p1 = Point::new(12, 13);
        let p2 = Point::new(16, 16);

        let mut poly = Polygon::new();
        poly.add_point(p1);
        poly.add_point(p2);
        assert_eq!(poly.left_most_point(), Some(&amp;p1));
    }

    #[test]
    fn test_polygon_iter() {
        let p1 = Point::new(12, 13);
        let p2 = Point::new(16, 16);

        let mut poly = Polygon::new();
        poly.add_point(p1);
        poly.add_point(p2);

        let points = poly.points.iter().cloned().collect::&lt;Vec&lt;_&gt;&gt;();
        assert_eq!(points, vec![Point::new(12, 13), Point::new(16, 16)]);
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="exercises-day-2---part-ii"><a class="header" href="#exercises-day-2---part-ii">Exercises Day 2 - Part II</a></h2>
<ul>
<li>luhn algorithm </li>
</ul>
<pre><pre class="playground"><code class="language-rust">pub fn luhn(cc_n: &amp;str) -&gt; bool {
    let mut sum = 0;
    let cc_number :String = cc_n.chars().filter(|c| !c.is_whitespace()).collect();
    let length = cc_number.len();
    let parity = length % 2;

    for (j, x) in cc_number.chars().enumerate() {
        let cc = cc_number.chars().nth(j).unwrap().to_digit(10);
        match cc {
            None =&gt; {}
            Some(mut n) =&gt; {
                if j % 2 == 0 {
                    n *= 2;
                    if n &gt; 9 {
                        n -= 9;
                    }
                }
                sum += n;
            }
        }
    }
    if sum == 0 {
        false
    } else {
        println!(&quot;{} {}&quot;, sum % 10, sum);
        sum % 10 == 0
    }
}

#[test]
fn test_non_digit_cc_number() {
    assert!(!luhn(&quot;foo&quot;));
}

#[test]
fn test_empty_cc_number() {
    assert!(!luhn(&quot;&quot;));
    assert!(!luhn(&quot; &quot;));
    assert!(!luhn(&quot;  &quot;));
    assert!(!luhn(&quot;    &quot;));
}

#[test]
fn test_single_digit_cc_number() {
    assert!(!luhn(&quot;0&quot;));
}

#[test]
fn test_two_digit_cc_number() {
    assert!(luhn(&quot; 0 0 &quot;));
}

#[test]
fn test_valid_cc_number() {
    assert!(luhn(&quot;4263 9826 4026 9299&quot;));
    assert!(luhn(&quot;4539 3195 0343 6467&quot;));
    assert!(luhn(&quot;7992 7398 7121 1114&quot;));
}

#[test]
fn test_invalid_cc_number() {
    assert!(!luhn(&quot;4223 9826 4026 9299&quot;));
    assert!(!luhn(&quot;4539 3195 0343 6476&quot;));
    assert!(!luhn(&quot;8273 1232 7352 0569&quot;));
}

#[allow(dead_code)]
fn main() {}</code></pre></pre>
<ul>
<li>Prefix matching </li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn is_prefix_of(haystack :&amp;str, p :&amp;str) -&gt; bool {
    haystack.as_bytes().starts_with(p.as_bytes())
}

pub fn prefix_matches(prefix: &amp;str, request_path: &amp;str) -&gt; bool {
    for (i, ph) in prefix.split(&quot;/&quot;).enumerate() {
        let p = request_path.split(&quot;/&quot;).nth(i);
        match p {
            Some(c) if ph== &quot;*&quot; =&gt; {},
            Some(c) if c != ph =&gt; return false,
            None =&gt; return false,
            _ =&gt; {}
        }
    }
    true
}

#[test]
fn test_matches_without_wildcard() {
    assert!(prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1/publishers&quot;));
    assert!(prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1/publishers/abc-123&quot;));
    assert!(prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1/publishers/abc/books&quot;));

    assert!(!prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1/publishersBooks&quot;));
    assert!(!prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1/parent/publishers&quot;));
    assert!(!prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1&quot;));
}

#[test]
fn test_matches_with_wildcard() {
    assert!(prefix_matches(
        &quot;/v1/publishers/*/books&quot;,
        &quot;/v1/publishers/foo/books&quot;
    ));
    assert!(prefix_matches(
        &quot;/v1/publishers/*/books&quot;,
        &quot;/v1/publishers/bar/books&quot;
    ));
    assert!(prefix_matches(
        &quot;/v1/publishers/*/books&quot;,
        &quot;/v1/publishers/foo/books/book1&quot;
    ));

    assert!(!prefix_matches(&quot;/v1/publishers/*/books&quot;, &quot;/v1/publishers&quot;));
    assert!(!prefix_matches(
        &quot;/v1/publishers/*/books&quot;,
        &quot;/v1/publishers/foo/booksByAuthor&quot;
    ));
}

fn main() {}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="day-3---142023"><a class="header" href="#day-3---142023">Day 3 - 1/4/2023</a></h3>
<h3 id="traits"><a class="header" href="#traits">Traits</a></h3>
<p>Traits are like interfaces and define a required amount of methods your struct needs to have.</p>
<pre><pre class="playground"><code class="language-rust edditable">fn main() {
    trait Cars {
        fn model(self) -&gt; String;
        fn board(&amp;self, number: i32) {
            println!(&quot;ABC{number}&quot;)
        }
    }

    struct Hundai {
        model :String
    }

    impl Cars for Hundai {
        fn model(self) -&gt; String {
            self.model
        }
    }
}</code></pre></pre>
<p>Traits can be derived and implement default behaviors</p>
<ul>
<li><code>Iterator</code> and <code>IntoIterator</code> for loops.</li>
<li><code>From</code> and <code>Into</code> to convert values.</li>
<li><code>Read</code> and <code>Write</code> for IO</li>
<li><code>Add, Mul</code> for operator overloading</li>
<li><code>Drop</code> for destructors</li>
</ul>
<pre><pre class="playground"><code class="language-rust">trait Cars {
    fn new() -&gt; Self;
}

struct Hundai {
    model :String
}

impl Cars for Hundai {
    fn new() -&gt; Self {
        Hundai{model: String::from(&quot;h&quot;) }
    }
}

impl Drop for Hundai {
    fn drop(&amp;mut self) {
        println!(&quot;dropping here&quot;);
    }
}

fn main() {
    {
        let h = Hundai::new();
        println!(&quot;{}&quot;, h.model);
    }
}</code></pre></pre>
<h3 id="generics"><a class="header" href="#generics">Generics</a></h3>
<p>Are used to create definitions for items like function sign or structs, which
we can then use with many different concrete data types.</p>
<p>Placing generics in signature allow reusability.
Different types are allowed in the same struct</p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

fn first&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T {
    &amp;list[0]
}

fn main() {
    println!(&quot;{}&quot;, first(&amp;vec![1,2,3,5]));
    println!(&quot;{}&quot;, first(&amp;vec![&quot;a&quot;, &quot;b&quot;]));
    let p = Point{x:5, y: 10};
    println!(&quot;{}&quot;, p.x);
}</code></pre></pre>
<p>The usage of trait (interfaces) with generics exists its possible to use a trait bound
and fix an allowed type of generic, its possible to return
an <code>impl Trait</code> on a function.</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display;

trait Form {
    fn area(&amp;self) -&gt; f32 ;
}

struct Square {
    side :f32
}

impl Form for Square {
    fn area(&amp;self) -&gt; f32 {
        self.side * self.side
    }
}

struct Circle {
    perimeter :f32
}

impl Form for Circle {
    fn area(&amp;self) -&gt; f32 {
        self.perimeter * self.perimeter * 3.14
    }
}

fn print_data(title: impl Display) -&gt; impl Display {
    format!(&quot; My area {title}&quot;)
}

fn main() {
    let forms: Vec&lt;Box&lt;dyn Form&gt;&gt; = vec![
        Box::new(Square{ side: 10.0 }),
        Box::new(Circle{perimeter: 10.0 })
    ];

    for f in forms.iter() {
        let area = f.area();
        println!(&quot;{}&quot;, print_data(area));
    }
}</code></pre></pre>
<h3 id="error-handling"><a class="header" href="#error-handling">Error handling</a></h3>
<p>Errors hit in two major categories: recoverable and unrecoverable.</p>
<p>Unrecoverables can be triggered with <code>panic!</code>, runtime errors will as well
possible to handle error with <code>catch_unwind</code></p>
<p>Structures errors handling with Result to code path. 
Returning results and adding context is allowed</p>
<pre><pre class="playground"><code class="language-rust">fn read() -&gt; Result&lt;string&gt; {
    Err()    
}

fn main() {
    match read() {
      Ok(f) =&gt; {},
      Err(err) =&gt; {}
    }
}</code></pre></pre>
<h3 id="testing"><a class="header" href="#testing">Testing</a></h3>
<p>Unit tests are supported and integrations are under <code>tests/</code>
Tests are headed as <code>#[test]</code> and run with <code>cargo test</code></p>
<h3 id="unsafe-rust"><a class="header" href="#unsafe-rust">Unsafe Rust</a></h3>
<p>Safe rust: memory safe
Unsafe rust: can trigger undefined behavior if preconditions are violed.</p>
<p>For a deep understanding read the https://doc.rust-lang.org/nomicon/
Use of <code>unsafe {}</code></p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>simple gui</li>
</ul>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Write;

pub trait Widget {
    /// Natural width of `self`.
    fn width(&amp;self) -&gt; usize;

    /// Draw the widget into a buffer.
    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write);

    /// Draw the widget on standard output.
    fn draw(&amp;self) {
        let mut buffer = String::new();
        self.draw_into(&amp;mut buffer);
        println!(&quot;{}&quot;, &amp;buffer);
    }
}

pub struct Label {
    label: String,
}

impl Label {
    fn new(label: &amp;str) -&gt; Label {
        Label {
            label: label.to_owned(),
        }
    }
}

pub struct Button {
    label: Label,
    callback: Box&lt;dyn FnMut()&gt;,
}

impl Button {
    fn new(label: &amp;str, callback: Box&lt;dyn FnMut()&gt;) -&gt; Button {
        Button {
            label: Label::new(label),
            callback,
        }
    }
}

pub struct Window {
    title: String,
    widgets: Vec&lt;Box&lt;dyn Widget&gt;&gt;,
}

impl Window {
    fn new(title: &amp;str) -&gt; Window {
        Window {
            title: title.to_owned(),
            widgets: Vec::new(),
        }
    }

    fn add_widget(&amp;mut self, widget: Box&lt;dyn Widget&gt;) {
        self.widgets.push(widget);
    }
}


impl Widget for Label {
    fn width(&amp;self) -&gt; usize {
        unimplemented!()
    }

    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {
        buffer.write_str(self.label.as_str()).unwrap();
    }
}

impl Widget for Button {
    fn width(&amp;self) -&gt; usize {
        unimplemented!()
    }

    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {
        buffer.write_str(&quot;\n|&quot;).unwrap();
        buffer.write_str(&amp;self.label.label.as_str()).unwrap();
        buffer.write_str(&quot;|\n&quot;).unwrap();
    }
}

impl Widget for Window {
    fn width(&amp;self) -&gt; usize {
        10
    }

    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {
        buffer.write_str(&quot;\n--------------\n&quot;).unwrap();
        buffer.write_str(self.title.as_str()).unwrap();
        buffer.write_str(&quot;\n--------------\n&quot;).unwrap();
        for w in &amp;self.widgets {
            w.draw_into(buffer)
        }
    }
}

fn main() {
    let mut window = Window::new(&quot;Rust GUI Demo 1.23&quot;);

    window.add_widget(Box::new(Label::new(&quot;This is a small text GUI demo.&quot;)));
    window.add_widget(Box::new(Button::new(
        &quot;Click me!&quot;,
        Box::new(|| println!(&quot;You clicked the button!&quot;)),
    )));

    window.draw();</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><pre class="playground"><code class="language-rust">
mod ffi {
    use std::os::raw::{c_char, c_int, c_long, c_ulong, c_ushort};

    // Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.
    #[repr(C)]
    pub struct DIR {
        _data: [u8; 0],
        _marker: core::marker::PhantomData&lt;(*mut u8, core::marker::PhantomPinned)&gt;,
    }

    // Layout as per readdir(3) and definitions in /usr/include/x86_64-linux-gnu.
    #[repr(C)]
    pub struct dirent {
        pub d_ino: c_long,
        pub d_off: c_ulong,
        pub d_reclen: c_ushort,
        pub d_type: c_char,
        pub d_name: [c_char; 256],
    }

    extern &quot;C&quot; {
        pub fn opendir(s: *const c_char) -&gt; *mut DIR;
        pub fn readdir(s: *mut DIR) -&gt; *const dirent;
        pub fn closedir(s: *mut DIR) -&gt; c_int;
    }
}

use std::ffi::{CStr, CString, OsStr, OsString};
use std::os::unix::ffi::OsStrExt;
use crate::ffi::opendir;

#[derive(Debug)]
struct DirectoryIterator {
    path: CString,
    dir: *mut ffi::DIR,
}

impl DirectoryIterator {
    fn new(path: &amp;str) -&gt; Result&lt;DirectoryIterator, String&gt; {
        unsafe {
            let path = CString::new(path).map_err(|err| format!(&quot;invalid path {err}&quot;))?;
            let dir = ffi::opendir(path.as_ptr());
            if dir.is_null() {
                return Err(format!(&quot;cannot not open {:?}&quot;, path))
            }
            Ok( DirectoryIterator{path, dir})
        }
    }
}

impl Iterator for DirectoryIterator {
    type Item = OsString;

    fn next(&amp;mut self) -&gt; Option&lt;OsString&gt; {
        let dirent = unsafe {ffi::readdir(self.dir)};
        if dirent.is_null() {
            return None;
        }
        let d_name = unsafe {CStr::from_ptr((*dirent).d_name.as_ptr())};
        let os_str = OsStr::from_bytes(d_name.to_bytes());

        Some(os_str.to_owned())
    }
}

fn main() -&gt; Result&lt;(), String&gt; {
    let iter = DirectoryIterator::new(&quot;.&quot;)?;
    println!(&quot;files: {:#?}&quot;, iter.collect::&lt;Vec&lt;_&gt;&gt;());
    Ok(())
}</code></pre></pre>
<p>Solution is under <a href="https://github.com/google/comprehensive-rust/blob/main/src/exercises/day-3/safe-ffi-wrapper.rs">here</a></p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="day-4---152023"><a class="header" href="#day-4---152023">Day 4 - 1/5/2023</a></h3>
<h3 id="concurrency"><a class="header" href="#concurrency">Concurrency</a></h3>
<p>Starting with threads, variables are shared via scope</p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let s = String::from(&quot;hello&quot;) ;
    thread::scope(|scope| {
        scope.spawn(|| {
            println!(&quot;str: {}&quot;, s.as_str());

            for i in 1..10 {
                println!(&quot;Count in thread: {i}! {s}&quot;);
                thread::sleep(Duration::from_millis(5));
            }
        });

        scope.spawn(|| {
            thread::sleep(Duration::from_millis(500));
            println!(&quot;new thread str: {}&quot;, s.as_str());
        });
    });
}</code></pre></pre>
<h3 id="channels"><a class="header" href="#channels">Channels</a></h3>
<p>Available as <code>Sender&lt;T&gt;</code> and <code>Receiver&lt;T&gt;</code>, uses the module str::sync:mpsc</p>
<p>Unbounded and async channels with <code>mpsc::channel</code> and bounded sync <code>mpsc::sync_channel</code></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let thread_id = thread::current().id();
        for i in 1..10 {
            tx.send(format!(&quot;Message {i}&quot;)).unwrap();
            println!(&quot;{thread_id:?}: sent Message {i}&quot;);
        }
        println!(&quot;{thread_id:?}: done&quot;);
    });
    thread::sleep(Duration::from_millis(100));

    for msg in rx.iter() {
        println!(&quot;Main: got {}&quot;, msg);
    }
}</code></pre></pre>
<h3 id="shared-state"><a class="header" href="#shared-state">Shared state</a></h3>
<ul>
<li><code>Arc&lt;T&gt;</code> allows shared read-only access via its <code>arc.clone()</code> methods across threads.</li>
<li><code>Mutex&lt;T&gt;</code> ensure mutual exclusion and allows mutable access to T behind a read-only interface.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::sync::Arc;

fn main() {
    let mut v = Arc::new(&quot;Shared data&quot;);
    let mut handles =  Vec::new();

    for _ in 1..5 {
        let v = v.clone();
        handles.push(thread::spawn(move || {
            println!(&quot;bla {v:?}&quot;)
        }))
    }

    handles.into_iter().for_each(|h| h.join().unwrap());
    println!(&quot;v: {v:?}&quot;);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="aws"><a class="header" href="#aws">AWS</a></h2>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
